{"version":3,"sources":["webpack:///./demo4/demo4.jsx","webpack:///./demo4/demo4.jsx?319e"],"names":[],"mappings":"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","sourcesContent":["var React = require(\"react\");\n\nvar TodoList = React.createClass({\n  // `TodoList` takes a prop called `items` which is an array of\n  // strings. We can make this requirement \"official\" using propTypes.\n  // If a component doesn't get the properties listed in its\n  // propTypes, it will warn you in the console (if using a development\n  // build of React).\n  propTypes: {\n    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\n  },\n\n  render() {\n    // Every component in an array should have a `key` attribute\n    // set so React can uniquely identify the item if it needs\n    // to remove it from the middle of the array without iterating\n    // over every component in the array.\n    // Since our todos can't be reordered, we'll just use the index.\n    //\n    // Also notice the use of another ES6 feature in the call to `map`,\n    // arrow functions. The bodies of arrow functions are automatically\n    // bound to the value of `this` outside of them, so no more calling\n    // `.bind(this)` or `var self = this` juggling.\n    return (\n      <ul>\n      {this.props.items.map((item, index) => {\n        return <li key={index}>{item}</li>;\n      })}\n      </ul>\n    );\n  }\n});\n\nvar TodoForm = React.createClass({\n  // React has PropTypes for most built-in JS types, as well as the\n  // ability to define your own validation functions.\n  //\n  // `TodoForm` requires an `onSubmit` property that we'll use to notify\n  // our parent component that the form has been submitted; this makes\n  // the component more reusable, since the logic for what to do with\n  // the submitted form isn't hardcoded into the `TodoForm` component.\n  propTypes: {\n    onSubmit: React.PropTypes.func.isRequired\n  },\n\n  // `TodoForm` contains a text input with a `value` attribute, which\n  // makes the input a \"controlled\" input. This means that the input\n  // will *always* display whatever is passed to its `value` no matter\n  // what the user tries to type in the box. The `text` property of\n  // our state is the current string to display in the box.\n  getInitialState() {\n    return {\n      text: \"\"\n    };\n  },\n\n  // The text input has an `onChange` property, which calls a function\n  // any time the user interacts with the box. Here, we update our\n  // state so the text in the box updates.\n  //\n  // This is necessary because React components' `render` functions should\n  // *always* describe how the component should look at *any* point and time;\n  // if we didn't use a controlled input, the text might reset in certain\n  // re-rendering situations.\n  onTextChange(e) {\n    this.setState({text: e.target.value});\n  },\n\n  // The form also has a handler for `onSubmit`...\n  onSubmit(e) {\n    e.preventDefault();\n    if (this.state.text.trim()) {\n      // ... which we'll use to indicate to our parent that an\n      // item has been submitted...\n      this.props.onSubmit(this.state.text);\n      // ... and then clear the text box.\n      this.setState({text: \"\"});\n    }\n  },\n\n  render() {\n    return (\n      <form onSubmit={this.onSubmit}>\n        <input type=\"text\" value={this.state.text} onChange={this.onTextChange} />\n        <input type=\"submit\" value=\"Add Todo\" />\n      </form>\n    );\n  }\n});\n\n// Our `Todos` component is the full application, which very simply composes\n// the `TodoList` and `TodoForm` components.\nvar Todos = React.createClass({\n  getInitialState() {\n    // It owns the actual items array, so the composed `TodoList`\n    // and `TodoForm` can be reused in many contexts (that is, they\n    // are not application specific).\n    return {\n      items: []\n    };\n  },\n\n  // `onSubmitTodo` is the function we pass to `TodoForm`'s\n  // `onSubmit` property; so, it will be called when `TodoForm`\n  // calls `this.props.onSubmit(...)`.\n  onSubmitTodo(newTodo) {\n    var nextItems = this.state.items.concat([newTodo]);\n    this.setState({items: nextItems});\n  },\n\n  render() {\n    return (\n      <div>\n        <h3>TODO</h3>\n        <TodoList items={this.state.items} />\n        <TodoForm onSubmit={this.onSubmitTodo} />\n      </div>\n    );\n  }\n});\n\nReact.render(\n  <Todos />,\n  document.getElementById(\"container\")\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo4/demo4.jsx\n **/","module.exports = \"var React = require(\\\"react\\\");\\n\\nvar TodoList = React.createClass({\\n  // `TodoList` takes a prop called `items` which is an array of\\n  // strings. We can make this requirement \\\"official\\\" using propTypes.\\n  // If a component doesn't get the properties listed in its\\n  // propTypes, it will warn you in the console (if using a development\\n  // build of React).\\n  propTypes: {\\n    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\\n  },\\n\\n  render() {\\n    // Every component in an array should have a `key` attribute\\n    // set so React can uniquely identify the item if it needs\\n    // to remove it from the middle of the array without iterating\\n    // over every component in the array.\\n    // Since our todos can't be reordered, we'll just use the index.\\n    //\\n    // Also notice the use of another ES6 feature in the call to `map`,\\n    // arrow functions. The bodies of arrow functions are automatically\\n    // bound to the value of `this` outside of them, so no more calling\\n    // `.bind(this)` or `var self = this` juggling.\\n    return (\\n      <ul>\\n      {this.props.items.map((item, index) => {\\n        return <li key={index}>{item}</li>;\\n      })}\\n      </ul>\\n    );\\n  }\\n});\\n\\nvar TodoForm = React.createClass({\\n  // React has PropTypes for most built-in JS types, as well as the\\n  // ability to define your own validation functions.\\n  //\\n  // `TodoForm` requires an `onSubmit` property that we'll use to notify\\n  // our parent component that the form has been submitted; this makes\\n  // the component more reusable, since the logic for what to do with\\n  // the submitted form isn't hardcoded into the `TodoForm` component.\\n  propTypes: {\\n    onSubmit: React.PropTypes.func.isRequired\\n  },\\n\\n  // `TodoForm` contains a text input with a `value` attribute, which\\n  // makes the input a \\\"controlled\\\" input. This means that the input\\n  // will *always* display whatever is passed to its `value` no matter\\n  // what the user tries to type in the box. The `text` property of\\n  // our state is the current string to display in the box.\\n  getInitialState() {\\n    return {\\n      text: \\\"\\\"\\n    };\\n  },\\n\\n  // The text input has an `onChange` property, which calls a function\\n  // any time the user interacts with the box. Here, we update our\\n  // state so the text in the box updates.\\n  //\\n  // This is necessary because React components' `render` functions should\\n  // *always* describe how the component should look at *any* point and time;\\n  // if we didn't use a controlled input, the text might reset in certain\\n  // re-rendering situations.\\n  onTextChange(e) {\\n    this.setState({text: e.target.value});\\n  },\\n\\n  // The form also has a handler for `onSubmit`...\\n  onSubmit(e) {\\n    e.preventDefault();\\n    if (this.state.text.trim()) {\\n      // ... which we'll use to indicate to our parent that an\\n      // item has been submitted...\\n      this.props.onSubmit(this.state.text);\\n      // ... and then clear the text box.\\n      this.setState({text: \\\"\\\"});\\n    }\\n  },\\n\\n  render() {\\n    return (\\n      <form onSubmit={this.onSubmit}>\\n        <input type=\\\"text\\\" value={this.state.text} onChange={this.onTextChange} />\\n        <input type=\\\"submit\\\" value=\\\"Add Todo\\\" />\\n      </form>\\n    );\\n  }\\n});\\n\\n// Our `Todos` component is the full application, which very simply composes\\n// the `TodoList` and `TodoForm` components.\\nvar Todos = React.createClass({\\n  getInitialState() {\\n    // It owns the actual items array, so the composed `TodoList`\\n    // and `TodoForm` can be reused in many contexts (that is, they\\n    // are not application specific).\\n    return {\\n      items: []\\n    };\\n  },\\n\\n  // `onSubmitTodo` is the function we pass to `TodoForm`'s\\n  // `onSubmit` property; so, it will be called when `TodoForm`\\n  // calls `this.props.onSubmit(...)`.\\n  onSubmitTodo(newTodo) {\\n    var nextItems = this.state.items.concat([newTodo]);\\n    this.setState({items: nextItems});\\n  },\\n\\n  render() {\\n    return (\\n      <div>\\n        <h3>TODO</h3>\\n        <TodoList items={this.state.items} />\\n        <TodoForm onSubmit={this.onSubmitTodo} />\\n      </div>\\n    );\\n  }\\n});\\n\\nReact.render(\\n  <Todos />,\\n  document.getElementById(\\\"container\\\")\\n);\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./demo4/demo4.jsx\n ** module id = 13\n ** module chunks = 4\n **/"],"sourceRoot":"","file":"4.bundle.js"}