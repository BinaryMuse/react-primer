{"version":3,"sources":["webpack:///4.bundle.js","webpack:///./demo4/demo4.jsx","webpack:///./demo4/demo4.jsx?319e"],"names":["webpackJsonp",6,"module","exports","__webpack_require__","React","TodoList","createClass","displayName","propTypes","items","PropTypes","arrayOf","string","isRequired","render","createElement","this","props","map","item","index","key","TodoForm","onSubmit","func","getInitialState","text","onTextChange","e","setState","target","value","preventDefault","state","trim","type","onChange","Todos","onSubmitTodo","newTodo","nextItems","concat","document","getElementById",13],"mappings":"AAAAA,cAAc,IAERC;;;AAIA,SAASC,EAAQC,EAASC,GCNhC,GAAIC,GAAQD,cAAQ,GAEhBE,EAAAD,EAAAE,aAA8BC,YAAA,WAMhCC,WACEC,MAAOL,EAAMM,UAAUC,QAAQP,EAAMM,UAAUE,QAAQC,YAGzDC,OAAM,WAWJ,MACEV,GAAAW,cAAA,KAAG,KACFC,KAAKC,MAAMR,MAAMS,IAAI,SAACC,EAAMC,GAC3B,MAAOhB,GAAAW,cAAA,MAAGM,IAACD,GAAYD,SAO3BG,EAAAlB,EAAAE,aAA8BC,YAAA,WAQhCC,WACEe,SAAUnB,EAAMM,UAAUc,KAAKX,YAQjCY,gBAAe,WACb,OACEC,KAAM,KAYVC,aAAY,SAACC,GACXZ,KAAKa,UAAUH,KAAME,EAAEE,OAAOC,SAIhCR,SAAQ,SAACK,GACPA,EAAEI,iBACEhB,KAAKiB,MAAMP,KAAKQ,SAGlBlB,KAAKC,MAAMM,SAASP,KAAKiB,MAAMP,MAE/BV,KAAKa,UAAUH,KAAM,OAIzBZ,OAAM,WACJ,MACEV,GAAAW,cAAA,QAAKQ,SAACP,KAAUO,UACdnB,EAAAW,cAAA,SAAMoB,KAAC,OAAKJ,MAAOf,KAAOiB,MAAKP,KAAMU,SAAMpB,KAAQW,eACnDvB,EAAAW,cAAA,SAAMoB,KAAC,SAAKJ,MAAS,iBAQzBM,EAAAjC,EAAAE,aAA2BC,YAAA,QAC7BkB,gBAAe,WAIb,OACEhB,WAOJ6B,aAAY,SAACC,GACX,GAAIC,GAAYxB,KAAKiB,MAAMxB,MAAMgC,QAAQF,GACzCvB,MAAKa,UAAUpB,MAAO+B,KAGxB1B,OAAM,WACJ,MACEV,GAAAW,cAAA,MAAI,KACFX,EAAAW,cAAA,KAAG,KAAC,QACJX,EAAAW,cAACV,GAAQI,MAACO,KAAOiB,MAAKxB,QACtBL,EAAAW,cAACO,GAAQC,SAACP,KAAUsB,kBAM5BlC,GAAMU,OACJV,EAAAW,cAACsB,EAAK,MACNK,SAASC,eAAe,eDcpBC;;;AAIA,SAAS3C,GE7IfA,EAAAC,QAAA","file":"4.bundle.js","sourcesContent":["webpackJsonp([4],{\n\n/***/ 6:\n/*!*************************!*\\\n  !*** ./demo4/demo4.jsx ***!\n  \\*************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar React = __webpack_require__(/*! react */ 1);\n\t\n\tvar TodoList = React.createClass({displayName: 'TodoList',\n\t  // `TodoList` takes a prop called `items` which is an array of\n\t  // strings. We can make this requirement \"official\" using propTypes.\n\t  // If a component doesn't get the properties listed in its\n\t  // propTypes, it will warn you in the console (if using a development\n\t  // build of React).\n\t  propTypes: {\n\t    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\n\t  },\n\t\n\t  render:function() {\n\t    // Every component in an array should have a `key` attribute\n\t    // set so React can uniquely identify the item if it needs\n\t    // to remove it from the middle of the array without iterating\n\t    // over every component in the array.\n\t    // Since our todos can't be reordered, we'll just use the index.\n\t    //\n\t    // Also notice the use of another ES6 feature in the call to `map`,\n\t    // arrow functions. The bodies of arrow functions are automatically\n\t    // bound to the value of `this` outside of them, so no more calling\n\t    // `.bind(this)` or `var self = this` juggling.\n\t    return (\n\t      React.createElement(\"ul\", null, \n\t      this.props.items.map(function(item, index)  {\n\t        return React.createElement(\"li\", {key: index}, item);\n\t      })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tvar TodoForm = React.createClass({displayName: 'TodoForm',\n\t  // React has PropTypes for most built-in JS types, as well as the\n\t  // ability to define your own validation functions.\n\t  //\n\t  // `TodoForm` requires an `onSubmit` property that we'll use to notify\n\t  // our parent component that the form has been submitted; this makes\n\t  // the component more reusable, since the logic for what to do with\n\t  // the submitted form isn't hardcoded into the `TodoForm` component.\n\t  propTypes: {\n\t    onSubmit: React.PropTypes.func.isRequired\n\t  },\n\t\n\t  // `TodoForm` contains a text input with a `value` attribute, which\n\t  // makes the input a \"controlled\" input. This means that the input\n\t  // will *always* display whatever is passed to its `value` no matter\n\t  // what the user tries to type in the box. The `text` property of\n\t  // our state is the current string to display in the box.\n\t  getInitialState:function() {\n\t    return {\n\t      text: \"\"\n\t    };\n\t  },\n\t\n\t  // The text input has an `onChange` property, which calls a function\n\t  // any time the user interacts with the box. Here, we update our\n\t  // state so the text in the box updates.\n\t  //\n\t  // This is necessary because React components' `render` functions should\n\t  // *always* describe how the component should look at *any* point and time;\n\t  // if we didn't use a controlled input, the text might reset in certain\n\t  // re-rendering situations.\n\t  onTextChange:function(e) {\n\t    this.setState({text: e.target.value});\n\t  },\n\t\n\t  // The form also has a handler for `onSubmit`...\n\t  onSubmit:function(e) {\n\t    e.preventDefault();\n\t    if (this.state.text.trim()) {\n\t      // ... which we'll use to indicate to our parent that an\n\t      // item has been submitted...\n\t      this.props.onSubmit(this.state.text);\n\t      // ... and then clear the text box.\n\t      this.setState({text: \"\"});\n\t    }\n\t  },\n\t\n\t  render:function() {\n\t    return (\n\t      React.createElement(\"form\", {onSubmit: this.onSubmit}, \n\t        React.createElement(\"input\", {type: \"text\", value: this.state.text, onChange: this.onTextChange}), \n\t        React.createElement(\"input\", {type: \"submit\", value: \"Add Todo\"})\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\t// Our `Todos` component is the full application, which very simply composes\n\t// the `TodoList` and `TodoForm` components.\n\tvar Todos = React.createClass({displayName: 'Todos',\n\t  getInitialState:function() {\n\t    // It owns the actual items array, so the composed `TodoList`\n\t    // and `TodoForm` can be reused in many contexts (that is, they\n\t    // are not application specific).\n\t    return {\n\t      items: []\n\t    };\n\t  },\n\t\n\t  // `onSubmitTodo` is the function we pass to `TodoForm`'s\n\t  // `onSubmit` property; so, it will be called when `TodoForm`\n\t  // calls `this.props.onSubmit(...)`.\n\t  onSubmitTodo:function(newTodo) {\n\t    var nextItems = this.state.items.concat([newTodo]);\n\t    this.setState({items: nextItems});\n\t  },\n\t\n\t  render:function() {\n\t    return (\n\t      React.createElement(\"div\", null, \n\t        React.createElement(\"h3\", null, \"TODO\"), \n\t        React.createElement(TodoList, {items: this.state.items}), \n\t        React.createElement(TodoForm, {onSubmit: this.onSubmitTodo})\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tReact.render(\n\t  React.createElement(Todos, null),\n\t  document.getElementById(\"container\")\n\t);\n\n\n/***/ },\n\n/***/ 13:\n/*!****************************************!*\\\n  !*** ./~/raw-loader!./demo4/demo4.jsx ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"var React = require(\\\"react\\\");\\n\\nvar TodoList = React.createClass({\\n  // `TodoList` takes a prop called `items` which is an array of\\n  // strings. We can make this requirement \\\"official\\\" using propTypes.\\n  // If a component doesn't get the properties listed in its\\n  // propTypes, it will warn you in the console (if using a development\\n  // build of React).\\n  propTypes: {\\n    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\\n  },\\n\\n  render() {\\n    // Every component in an array should have a `key` attribute\\n    // set so React can uniquely identify the item if it needs\\n    // to remove it from the middle of the array without iterating\\n    // over every component in the array.\\n    // Since our todos can't be reordered, we'll just use the index.\\n    //\\n    // Also notice the use of another ES6 feature in the call to `map`,\\n    // arrow functions. The bodies of arrow functions are automatically\\n    // bound to the value of `this` outside of them, so no more calling\\n    // `.bind(this)` or `var self = this` juggling.\\n    return (\\n      <ul>\\n      {this.props.items.map((item, index) => {\\n        return <li key={index}>{item}</li>;\\n      })}\\n      </ul>\\n    );\\n  }\\n});\\n\\nvar TodoForm = React.createClass({\\n  // React has PropTypes for most built-in JS types, as well as the\\n  // ability to define your own validation functions.\\n  //\\n  // `TodoForm` requires an `onSubmit` property that we'll use to notify\\n  // our parent component that the form has been submitted; this makes\\n  // the component more reusable, since the logic for what to do with\\n  // the submitted form isn't hardcoded into the `TodoForm` component.\\n  propTypes: {\\n    onSubmit: React.PropTypes.func.isRequired\\n  },\\n\\n  // `TodoForm` contains a text input with a `value` attribute, which\\n  // makes the input a \\\"controlled\\\" input. This means that the input\\n  // will *always* display whatever is passed to its `value` no matter\\n  // what the user tries to type in the box. The `text` property of\\n  // our state is the current string to display in the box.\\n  getInitialState() {\\n    return {\\n      text: \\\"\\\"\\n    };\\n  },\\n\\n  // The text input has an `onChange` property, which calls a function\\n  // any time the user interacts with the box. Here, we update our\\n  // state so the text in the box updates.\\n  //\\n  // This is necessary because React components' `render` functions should\\n  // *always* describe how the component should look at *any* point and time;\\n  // if we didn't use a controlled input, the text might reset in certain\\n  // re-rendering situations.\\n  onTextChange(e) {\\n    this.setState({text: e.target.value});\\n  },\\n\\n  // The form also has a handler for `onSubmit`...\\n  onSubmit(e) {\\n    e.preventDefault();\\n    if (this.state.text.trim()) {\\n      // ... which we'll use to indicate to our parent that an\\n      // item has been submitted...\\n      this.props.onSubmit(this.state.text);\\n      // ... and then clear the text box.\\n      this.setState({text: \\\"\\\"});\\n    }\\n  },\\n\\n  render() {\\n    return (\\n      <form onSubmit={this.onSubmit}>\\n        <input type=\\\"text\\\" value={this.state.text} onChange={this.onTextChange} />\\n        <input type=\\\"submit\\\" value=\\\"Add Todo\\\" />\\n      </form>\\n    );\\n  }\\n});\\n\\n// Our `Todos` component is the full application, which very simply composes\\n// the `TodoList` and `TodoForm` components.\\nvar Todos = React.createClass({\\n  getInitialState() {\\n    // It owns the actual items array, so the composed `TodoList`\\n    // and `TodoForm` can be reused in many contexts (that is, they\\n    // are not application specific).\\n    return {\\n      items: []\\n    };\\n  },\\n\\n  // `onSubmitTodo` is the function we pass to `TodoForm`'s\\n  // `onSubmit` property; so, it will be called when `TodoForm`\\n  // calls `this.props.onSubmit(...)`.\\n  onSubmitTodo(newTodo) {\\n    var nextItems = this.state.items.concat([newTodo]);\\n    this.setState({items: nextItems});\\n  },\\n\\n  render() {\\n    return (\\n      <div>\\n        <h3>TODO</h3>\\n        <TodoList items={this.state.items} />\\n        <TodoForm onSubmit={this.onSubmitTodo} />\\n      </div>\\n    );\\n  }\\n});\\n\\nReact.render(\\n  <Todos />,\\n  document.getElementById(\\\"container\\\")\\n);\\n\"\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** 4.bundle.js\n **/","var React = require(\"react\");\n\nvar TodoList = React.createClass({\n  // `TodoList` takes a prop called `items` which is an array of\n  // strings. We can make this requirement \"official\" using propTypes.\n  // If a component doesn't get the properties listed in its\n  // propTypes, it will warn you in the console (if using a development\n  // build of React).\n  propTypes: {\n    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\n  },\n\n  render() {\n    // Every component in an array should have a `key` attribute\n    // set so React can uniquely identify the item if it needs\n    // to remove it from the middle of the array without iterating\n    // over every component in the array.\n    // Since our todos can't be reordered, we'll just use the index.\n    //\n    // Also notice the use of another ES6 feature in the call to `map`,\n    // arrow functions. The bodies of arrow functions are automatically\n    // bound to the value of `this` outside of them, so no more calling\n    // `.bind(this)` or `var self = this` juggling.\n    return (\n      <ul>\n      {this.props.items.map((item, index) => {\n        return <li key={index}>{item}</li>;\n      })}\n      </ul>\n    );\n  }\n});\n\nvar TodoForm = React.createClass({\n  // React has PropTypes for most built-in JS types, as well as the\n  // ability to define your own validation functions.\n  //\n  // `TodoForm` requires an `onSubmit` property that we'll use to notify\n  // our parent component that the form has been submitted; this makes\n  // the component more reusable, since the logic for what to do with\n  // the submitted form isn't hardcoded into the `TodoForm` component.\n  propTypes: {\n    onSubmit: React.PropTypes.func.isRequired\n  },\n\n  // `TodoForm` contains a text input with a `value` attribute, which\n  // makes the input a \"controlled\" input. This means that the input\n  // will *always* display whatever is passed to its `value` no matter\n  // what the user tries to type in the box. The `text` property of\n  // our state is the current string to display in the box.\n  getInitialState() {\n    return {\n      text: \"\"\n    };\n  },\n\n  // The text input has an `onChange` property, which calls a function\n  // any time the user interacts with the box. Here, we update our\n  // state so the text in the box updates.\n  //\n  // This is necessary because React components' `render` functions should\n  // *always* describe how the component should look at *any* point and time;\n  // if we didn't use a controlled input, the text might reset in certain\n  // re-rendering situations.\n  onTextChange(e) {\n    this.setState({text: e.target.value});\n  },\n\n  // The form also has a handler for `onSubmit`...\n  onSubmit(e) {\n    e.preventDefault();\n    if (this.state.text.trim()) {\n      // ... which we'll use to indicate to our parent that an\n      // item has been submitted...\n      this.props.onSubmit(this.state.text);\n      // ... and then clear the text box.\n      this.setState({text: \"\"});\n    }\n  },\n\n  render() {\n    return (\n      <form onSubmit={this.onSubmit}>\n        <input type=\"text\" value={this.state.text} onChange={this.onTextChange} />\n        <input type=\"submit\" value=\"Add Todo\" />\n      </form>\n    );\n  }\n});\n\n// Our `Todos` component is the full application, which very simply composes\n// the `TodoList` and `TodoForm` components.\nvar Todos = React.createClass({\n  getInitialState() {\n    // It owns the actual items array, so the composed `TodoList`\n    // and `TodoForm` can be reused in many contexts (that is, they\n    // are not application specific).\n    return {\n      items: []\n    };\n  },\n\n  // `onSubmitTodo` is the function we pass to `TodoForm`'s\n  // `onSubmit` property; so, it will be called when `TodoForm`\n  // calls `this.props.onSubmit(...)`.\n  onSubmitTodo(newTodo) {\n    var nextItems = this.state.items.concat([newTodo]);\n    this.setState({items: nextItems});\n  },\n\n  render() {\n    return (\n      <div>\n        <h3>TODO</h3>\n        <TodoList items={this.state.items} />\n        <TodoForm onSubmit={this.onSubmitTodo} />\n      </div>\n    );\n  }\n});\n\nReact.render(\n  <Todos />,\n  document.getElementById(\"container\")\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo4/demo4.jsx\n **/","module.exports = \"var React = require(\\\"react\\\");\\n\\nvar TodoList = React.createClass({\\n  // `TodoList` takes a prop called `items` which is an array of\\n  // strings. We can make this requirement \\\"official\\\" using propTypes.\\n  // If a component doesn't get the properties listed in its\\n  // propTypes, it will warn you in the console (if using a development\\n  // build of React).\\n  propTypes: {\\n    items: React.PropTypes.arrayOf(React.PropTypes.string).isRequired\\n  },\\n\\n  render() {\\n    // Every component in an array should have a `key` attribute\\n    // set so React can uniquely identify the item if it needs\\n    // to remove it from the middle of the array without iterating\\n    // over every component in the array.\\n    // Since our todos can't be reordered, we'll just use the index.\\n    //\\n    // Also notice the use of another ES6 feature in the call to `map`,\\n    // arrow functions. The bodies of arrow functions are automatically\\n    // bound to the value of `this` outside of them, so no more calling\\n    // `.bind(this)` or `var self = this` juggling.\\n    return (\\n      <ul>\\n      {this.props.items.map((item, index) => {\\n        return <li key={index}>{item}</li>;\\n      })}\\n      </ul>\\n    );\\n  }\\n});\\n\\nvar TodoForm = React.createClass({\\n  // React has PropTypes for most built-in JS types, as well as the\\n  // ability to define your own validation functions.\\n  //\\n  // `TodoForm` requires an `onSubmit` property that we'll use to notify\\n  // our parent component that the form has been submitted; this makes\\n  // the component more reusable, since the logic for what to do with\\n  // the submitted form isn't hardcoded into the `TodoForm` component.\\n  propTypes: {\\n    onSubmit: React.PropTypes.func.isRequired\\n  },\\n\\n  // `TodoForm` contains a text input with a `value` attribute, which\\n  // makes the input a \\\"controlled\\\" input. This means that the input\\n  // will *always* display whatever is passed to its `value` no matter\\n  // what the user tries to type in the box. The `text` property of\\n  // our state is the current string to display in the box.\\n  getInitialState() {\\n    return {\\n      text: \\\"\\\"\\n    };\\n  },\\n\\n  // The text input has an `onChange` property, which calls a function\\n  // any time the user interacts with the box. Here, we update our\\n  // state so the text in the box updates.\\n  //\\n  // This is necessary because React components' `render` functions should\\n  // *always* describe how the component should look at *any* point and time;\\n  // if we didn't use a controlled input, the text might reset in certain\\n  // re-rendering situations.\\n  onTextChange(e) {\\n    this.setState({text: e.target.value});\\n  },\\n\\n  // The form also has a handler for `onSubmit`...\\n  onSubmit(e) {\\n    e.preventDefault();\\n    if (this.state.text.trim()) {\\n      // ... which we'll use to indicate to our parent that an\\n      // item has been submitted...\\n      this.props.onSubmit(this.state.text);\\n      // ... and then clear the text box.\\n      this.setState({text: \\\"\\\"});\\n    }\\n  },\\n\\n  render() {\\n    return (\\n      <form onSubmit={this.onSubmit}>\\n        <input type=\\\"text\\\" value={this.state.text} onChange={this.onTextChange} />\\n        <input type=\\\"submit\\\" value=\\\"Add Todo\\\" />\\n      </form>\\n    );\\n  }\\n});\\n\\n// Our `Todos` component is the full application, which very simply composes\\n// the `TodoList` and `TodoForm` components.\\nvar Todos = React.createClass({\\n  getInitialState() {\\n    // It owns the actual items array, so the composed `TodoList`\\n    // and `TodoForm` can be reused in many contexts (that is, they\\n    // are not application specific).\\n    return {\\n      items: []\\n    };\\n  },\\n\\n  // `onSubmitTodo` is the function we pass to `TodoForm`'s\\n  // `onSubmit` property; so, it will be called when `TodoForm`\\n  // calls `this.props.onSubmit(...)`.\\n  onSubmitTodo(newTodo) {\\n    var nextItems = this.state.items.concat([newTodo]);\\n    this.setState({items: nextItems});\\n  },\\n\\n  render() {\\n    return (\\n      <div>\\n        <h3>TODO</h3>\\n        <TodoList items={this.state.items} />\\n        <TodoForm onSubmit={this.onSubmitTodo} />\\n      </div>\\n    );\\n  }\\n});\\n\\nReact.render(\\n  <Todos />,\\n  document.getElementById(\\\"container\\\")\\n);\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./demo4/demo4.jsx\n ** module id = 13\n ** module chunks = 4\n **/"],"sourceRoot":""}